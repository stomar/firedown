#!/usr/bin/ruby -w
# == Name
#
# firedown - file-based (remote) shutdown
#
# == Synopsis
#
#    firedown [options] directories
#
# == Description
#
# +firedown+ is a command line tool
# that enables a remote shutdown of a Linux system
# via Dropbox or other file synchronization services.
#
# +firedown+ monitors a specified directory (or several directories)
# on the system for the presence of a trigger file or directory.
# If a trigger is found, +firedown+ issues a shutdown.
#
# The monitored directory might be synchronized via remote services
# like Dropbox or Ubuntu One, thus enabling a remotely triggered
# shutdown of the system.
#
# Bring down the system by creating +firedown.host+
# as empty trigger file or as empty directory in any of the
# monitored directories, where +host+ is the hostname
# of the system you want to bring down.
#
# == Options
#
# -d, --[no-]daemon:: Detach and run in the background (implies --log).
#                     Checks for a trigger file every 15 seconds.
#
# -l, --[no-]log:: Write messages to log file (\`/var/log/firedown.log') instead of stderr.
#
#     --logging-level LEVEL:: Set logging level (+info+, +debug+). Default is +info+.
#
# -n, --no-act:: Do not bring down the system.
#                Detects, reports, and removes trigger files, but does not issue a shutdown.
#
# == Files
#
# +/var/log/firedown.log+:: Default log file.
#
# == Signals
#
# +SIGUSR1+:: Toggle logging between +info+ and +debug+ level.
#
# == See also
#
# The full documentation for +firedown+ is available on the
# project home page: <https://github.com/stomar/firedown/>
#
# == Author
#
# Copyright (C) 2012 Marcus Stollsteimer
#
# License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
#

require 'optparse'
require 'socket'

# This module contains the classes for the +firedown+ tool.
module Firedown

  PROGNAME  = 'firedown'
  VERSION   = '0.0.1'
  DATE      = '2012-07-07'
  HOMEPAGE  = 'https://github.com/stomar/firedown/'

  COPYRIGHT = "Copyright (C) 2012 Marcus Stollsteimer.\n" +
              "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n" +
              "This is free software: you are free to change and redistribute it.\n" +
              "There is NO WARRANTY, to the extent permitted by law."

  # Parser for the command line options.
  # The class method parse! does the job.
  class Optionparser

    # Parses the command line options from +argv+.
    # (+argv+ is cleared).
    # Might print out help or version information.
    #
    # +argv+ - array with the command line options
    #
    # Returns a hash containing the option parameters.
    def self.parse!(argv)

      options = {
        :daemon_mode => false,
        :directories => nil,
        :log         => false,
        :log_file    => "/var/log/#{PROGNAME}.log",
        :log_level   => :info,
        :simulate    => false
      }

      opt_parser = OptionParser.new do |opt|
        opt.banner = "Usage: #{PROGNAME} [options] directories"
        opt.separator ''
        opt.separator 'firedown is a command line tool'
        opt.separator 'that enables a remote shutdown of a Linux system'
        opt.separator 'via Dropbox or other file synchronization services.'
        opt.separator ''
        opt.separator 'firedown monitors a specified directory (or several directories)'
        opt.separator 'on the system for the presence of a trigger file or directory.'
        opt.separator 'If a trigger is found, firedown issues a shutdown.'
        opt.separator ''
        opt.separator 'The monitored directory might be synchronized via remote services'
        opt.separator 'like Dropbox or Ubuntu One, thus enabling a remotely triggered'
        opt.separator 'shutdown of the system.'
        opt.separator ''
        opt.separator "Bring down the system by creating `firedown.host'"
        opt.separator 'as empty trigger file or as empty directory in any of the'
        opt.separator "monitored directories, where `host' is the hostname"
        opt.separator 'of the system you want to bring down.'
        opt.separator ''
        opt.separator 'Options'
        opt.separator ''

        # process --version and --help first,
        # exit successfully (GNU Coding Standards)
        opt.on_tail('-h', '--help', 'Prints a brief help message and exits.') do
          puts opt_parser
          puts "\nReport bugs on the #{PROGNAME} home page: <#{HOMEPAGE}>"
          exit
        end

        opt.on_tail('-v', '--version',
                    'Prints a brief version information and exits.') do
          puts "#{PROGNAME} #{VERSION}"
          puts COPYRIGHT
          exit
        end

        opt.on('-d', '--[no-]daemon',
               'Detach and run in the background (implies --log).',
               'Checks for a trigger file every 15 seconds.') do |d|
          options[:daemon_mode] = d
        end

        opt.on('--logging-level LEVEL', [:debug, :info],
               "Set logging level (info, debug). Default is `info'.") do |l|
          options[:log_level] = l
        end

        opt.on('-l', '--[no-]log',
               "Write messages to log file (`#{options[:log_file]}') instead of stderr.") do |l|
          options[:log] = l
        end

        opt.on('-n', '--no-act',
               'Do not bring down the system.',
               'Detects, reports, and removes trigger files, but does not issue a shutdown.') do
          options[:simulate] = true
        end

        opt.separator ''
      end
      opt_parser.parse!(argv)

      options[:log] = true  if options[:daemon_mode]

      # only directories should be left in argv
      argv.delete('')
      raise(ArgumentError, 'wrong number of arguments')  if argv.size < 1

      options[:directories] = argv.pop(argv.size).map {|dir| File.expand_path(dir) }

      options
    end
  end


  # Class for logging messages.
  #
  # Create a new logger with
  #   logger = Logger.new(device)
  # where +device+ is a path or <tt>'STDERR'</tt>.
  #
  # Log an info or debug message with
  #   logger.info  'Info message.'
  #   logger.debug 'Debug message.'
  #
  # Default logging level is :info,
  # change to :debug with
  #   logger.level = :debug
  class Logger

    attr_accessor :level

    def initialize(device)
      if device == 'STDERR'
        @log_to_file = false
      else
        @log_to_file = true
        @log_file = device
      end
      @level = :info
    end

    # Writes a log entry with time stamp (to stderr or to file).
    def add(message)
      message = self.class.time_to_string(Time.now) << ': ' << message
      if @log_to_file
        File.open(@log_file, 'a') {|f| f.puts message }
      else
        warn message
      end
    end

    # Logs an info message.
    def info(message)
      add message
    end

    # Logs a debug message.
    def debug(message)
      add message  if @level == :debug
    end

    # Returns a formatted string for a Time object.
    def self.time_to_string(time)
      time_string = if RUBY_VERSION =~ /1\.8/
                      time.strftime('%Y-%m-%d %H:%M:%S ') << time.zone
                    else
                      time.strftime('%Y-%m-%d %H:%M:%S %Z')
                    end

      time_string
    end
  end


  # The main program. It's run! method is called
  # if the script is run from the command line.
  # It parses the command line arguments and does the job.
  class Application

    ERRORCODE = {:general => 1, :usage => 2}

    def initialize
      # parse options
      begin
        options = Optionparser.parse!(ARGV)
      rescue => e
        usage_fail(e.message)
      end

      @simulate = options[:simulate]
      @daemon_mode = options[:daemon_mode]
      @log_to_file = options[:log]
      @log_file = options[:log_file]
      @logging_level = options[:log_level]

      # make sure log file exists and is writable by user
      if @log_to_file
        begin
          File.open(@log_file, 'a') {}
        rescue
          warn "Log file `#{@log_file}' not writable, stderr is used instead."
          @log_to_file = false
        end
      end

      device = @log_to_file ? @log_file : 'STDERR'
      @logger = Logger.new(device)
      @logger.level = @logging_level

      @hostname = Socket::gethostname
      @hostname = 'all'  if (@hostname.empty? or @hostname.nil?)

      @trigger_files = options[:directories].map {|dir| "#{dir}/#{PROGNAME}.#{@hostname}" }

      @sleep_time = 15  # checks every ... seconds
    end

    # The main program.
    def run!
      if @daemon_mode
        launch_message = "#{PROGNAME} daemon has been launched"
        launch_message << (@simulate ? ' in no-act mode.' : '.')
        daemonize do
          @logger.info launch_message
          @logger.info "Monitoring `#{@trigger_files.join("', `")}'..."
          @logger.info "Logging level is `#{@logger.level}'."
          loop do
            check_and_act
            sleep @sleep_time
          end
        end
        warn launch_message
        warn "Monitoring `#{@trigger_files.join("', `")}'..."
      else
        check_and_act
      end
    end

    # Checks for trigger files and handles them.
    def check_and_act
      @logger.debug 'Checking for trigger files.'
      shutdown_triggered = false

      @trigger_files.each do |trigger|
        next  unless File.exist?(trigger)
        @logger.info "`#{trigger}' detected."

        begin  # just in case...
          if File.directory?(trigger)
            Dir.rmdir(trigger)  if Dir.entries(trigger).join == '...'  # empty
          else
            File.delete(trigger)  if File.stat(trigger).size == 0
          end
        rescue
        end

        if File.exist?(trigger)
          @logger.info "Trigger invalid (`#{trigger}' could not be removed)."
        else
          shutdown_triggered = true
        end
      end

      return  unless shutdown_triggered

      if @simulate
        @logger.info 'This is a simulated shutdown!'
      else
        @logger.info 'Shutting down in 60 seconds!'
        system('shutdown -h +1')
      end
    end

    # Daemonizes a block (see 'Beginning Ruby' by Peter Cooper).
    def daemonize
      fork do
        Process.setsid
        exit  if fork
        Dir.chdir('/')
        STDIN.reopen('/dev/null')
        STDOUT.reopen('/dev/null', 'a')
        STDERR.reopen('/dev/null', 'a')
        trap('TERM') do
          @logger.info "#{PROGNAME} daemon has been stopped."
          exit
        end
        trap('USR1') do
          @logger.level = case @logger.level
                          when :debug
                            :info
                          when :info
                            :debug
                          end
          @logger.info "Logging level changed to `#{@logger.level}'."
        end
        yield
      end
    end

    # Prints an error message and exits.
    def general_fail(message) # :nodoc:
      warn "#{PROGNAME}: #{message}"
      exit ERRORCODE[:general]
    end

    # Prints an error message and a short help information, then exits.
    def usage_fail(message) # :nodoc:
      warn "#{PROGNAME}: #{message}"
      warn "Use `#{PROGNAME} --help' for valid options."
      exit ERRORCODE[:usage]
    end
  end

### call main method only if called on command line

if __FILE__ == $0
  Application.new.run!
end

end  # module
